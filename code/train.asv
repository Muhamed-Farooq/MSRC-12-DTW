function [model, samples] = train(gesture)
    % Loading and extracting all the sequences of the given gesture.
    samples = getSamples(gesture);
    
    % Selecting the model sequence.
    modelIndex = 1;         % TODO: chosen by the user
    modelSequence = samples{modelIndex, 1};
    samples(modelIndex, :) = [];        % Deleting the model from the samples.
    
    % Comparing the model with all the samples.
    
    for i = 1:size(samples, 1)
        sample =
        errorMap = dtw(modelSequence, sample, 'match');
        %samples{nSamples, 2} = min(errorMap(end, round(19/20 * end):end));
        samples{nSamples, 2} = errorMap(end, end);
        samples{nSamples, 3} = errorMap;
        samples{nSamples, 4} = 0;           % Insertions

        [r, c] = size(errorMap);

        while r > 1 && c > 1
            chosenR = r;
            chosenC = c - 1;

            if errorMap(r - 1, c) <= errorMap(chosenR, chosenC)
                chosenR = r - 1;
                chosenC = c;
            end

            if errorMap(r - 1, c - 1) <= errorMap(chosenR, chosenC)
                chosenR = r - 1;
                chosenC = c - 1;
            end

            if chosenC == c
                samples{nSamples, 4} = samples{nSamples, 4} + 1;
            end

            r = chosenR;
            c = chosenC;
        end
    end
    
    % Sorting the samples by error (for future analysis).
    [~, idx] = sort([samples{:, 2}], 'ascend');
    samples = samples(idx, :);
    
    % Calculating thresholds.
    %maxErrorThreshold = samples{end, 2};
    maxErrorThreshold = mean([samples{:,2}]) + 3 * std([samples{:,2}]);
    %maxInsertions = max([samples{:, 4}]);
    maxInsertions = mean([samples{:, 4}]) + 3 * std([samples{:, 4}]);
    
    lastInsertionThreshold = 0;
    n = size(modelSequence, 1);
    
    for i = 1:size(samples, 1)
        errorMap = samples{i, 3};
        currentLastInsertion = 1;
        
        while currentLastInsertion < n
            if errorMap(n - currentLastInsertion, end - 1) <= errorMap(n - currentLastInsertion, end)
                break;
            end
            
            currentLastInsertion = currentLastInsertion + 1;
        end
        
        if currentLastInsertion > lastInsertionThreshold
            lastInsertionThreshold = currentLastInsertion;
        end
    end
    
    % Generating the model.
    model = struct('sequence', modelSequence, 'maxErrorThreshold', maxErrorThreshold, 'maxInsertions', maxInsertions, 'lastInsertionThreshold', lastInsertionThreshold, 'gesture', gesture);
end

